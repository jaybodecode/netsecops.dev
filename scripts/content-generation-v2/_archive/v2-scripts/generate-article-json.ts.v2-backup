#!/usr/bin/env node
/**
 * Content Generation V2 - Step 7B: Generate Article JSON Files
 * 
 * Generates individual article JSON files for the website from the normalized database.
 * 
 * Input:
 *   - Database: published_articles, article_updates
 *   - Enrichment: structured_news JSON blob for full article metadata
 * 
 * Output:
 *   - /public/data/articles/{slug}.json
 * 
 * Usage:
 *   npx tsx scripts/content-generation-v2/generate-article-json.ts --slug article-slug
 *   npx tsx scripts/content-generation-v2/generate-article-json.ts --date 2025-10-09
 *   npx tsx scripts/content-generation-v2/generate-article-json.ts --all
 */

import { getDB } from './database/index.js';
import type { PublishedArticle, ArticleUpdate } from './database/schema-published-articles.js';
import { existsSync, mkdirSync, writeFileSync } from 'fs';
import { join } from 'path';

/**
 * CLI arguments
 */
interface Args {
  slug?: string;        // Generate for specific article slug
  date?: string;        // Generate for articles published on date
  all?: boolean;        // Generate all articles
  outputDir?: string;   // Output directory (default: public/data/articles)
}

/**
 * Complete article structure from structured_news
 */
interface StructuredArticle {
  id: string;
  slug: string;
  headline: string;
  title: string;
  summary: string;
  full_report: string;
  twitter_post?: string;
  meta_description?: string;
  category: string[];
  severity: string;
  entities?: Array<{
    name: string;
    type: string;
  }>;
  cves?: Array<string | {
    id: string;
    cvss_score?: number;
    description?: string;
  }>;
  sources?: Array<{
    url: string;
    title: string;
  }>;
  events?: Array<{
    datetime: string;
    summary: string;
  }>;
  mitre_techniques?: Array<{
    id: string;
    name: string;
    tactic: string;
  }>;
  tags: string[];
  extract_datetime: string;
  article_type?: string;
  impact_scope?: {
    countries_affected?: string[];
    industries_affected?: string[];
    organizations_affected?: string[];
  };
  keywords?: string[];
  pub_date?: string;
  reading_time_minutes?: number;
}

/**
 * Article JSON output structure
 */
interface ArticleOutput extends StructuredArticle {
  createdAt: string;
  updatedAt?: string;
  updates?: Array<{
    update_id: string;
    update_date: string;
    title: string;
    summary: string;
  }>;
}

/**
 * Parse CLI arguments
 */
function parseArgs(): Args {
  const args: Args = {};
  
  for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];
    
    if (arg === '--slug' && i + 1 < process.argv.length) {
      args.slug = process.argv[++i];
    } else if (arg === '--date' && i + 1 < process.argv.length) {
      args.date = process.argv[++i];
    } else if (arg === '--all') {
      args.all = true;
    } else if (arg === '--output' && i + 1 < process.argv.length) {
      args.outputDir = process.argv[++i];
    }
  }
  
  return args;
}

/**
 * Get published article by slug
 */
function getPublishedArticleBySlug(slug: string): PublishedArticle | null {
  const db = getDB();
  
  const stmt = db.prepare(`
    SELECT * FROM published_articles
    WHERE slug = ?
  `);
  
  return stmt.get(slug) as PublishedArticle | null;
}

/**
 * Get articles published on specific date
 */
function getArticlesByDate(date: string): PublishedArticle[] {
  const db = getDB();
  
  const stmt = db.prepare(`
    SELECT * FROM published_articles
    WHERE original_pub_date = ?
    ORDER BY position
  `);
  
  return stmt.all(date) as PublishedArticle[];
}

/**
 * Get all published articles
 */
function getAllPublishedArticles(): PublishedArticle[] {
  const db = getDB();
  
  const stmt = db.prepare(`
    SELECT * FROM published_articles
    ORDER BY original_pub_date DESC, position
  `);
  
  return stmt.all() as PublishedArticle[];
}

/**
 * Get updates for an article
 */
function getArticleUpdates(articleId: string): ArticleUpdate[] {
  const db = getDB();
  
  const stmt = db.prepare(`
    SELECT * FROM article_updates
    WHERE article_id = ?
    ORDER BY update_date DESC
  `);
  
  return stmt.all(articleId) as ArticleUpdate[];
}

/**
 * Find article in structured_news by ID
 */
function findArticleInStructuredNews(articleId: string): StructuredArticle | null {
  const db = getDB();
  
  // Search in all structured_news entries (ordered by date desc)
  const stmt = db.prepare(`
    SELECT pub_date, data FROM structured_news
    ORDER BY pub_date DESC
  `);
  
  const results = stmt.all() as Array<{ pub_date: string; data: string }>;
  
  for (const result of results) {
    try {
      const data = JSON.parse(result.data);
      const article = data.articles?.find((a: any) => a.id === articleId);
      if (article) {
        return article;
      }
    } catch (error) {
      // Skip invalid JSON
      continue;
    }
  }
  
  return null;
}

/**
 * Calculate reading time from text
 */
function calculateReadingTime(text: string): number {
  const wordsPerMinute = 200;
  const words = text.trim().split(/\s+/).length;
  return Math.ceil(words / wordsPerMinute);
}

/**
 * Format article updates for output
 */
function formatArticleUpdates(updates: ArticleUpdate[]): Array<{
  update_id: string;
  update_date: string;
  title: string;
  summary: string;
}> {
  return updates.map((update, index) => ({
    update_id: `update-${index + 1}`,
    update_date: update.update_date,
    title: `Update ${index + 1}`,
    summary: update.update_summary
  }));
}

/**
 * Generate article JSON file
 */
async function generateArticleJson(
  article: PublishedArticle,
  outputDir: string
): Promise<void> {
  console.log(`\nðŸ“ Generating article JSON: ${article.slug}`);
  console.log(`   Article ID: ${article.id}`);
  console.log(`   Original Date: ${article.original_pub_date}`);
  
  // Get full article data from structured_news
  const structuredArticle = findArticleInStructuredNews(article.id);
  
  if (!structuredArticle) {
    console.log(`   âš ï¸  No structured data found for article, skipping...`);
    return;
  }
  
  console.log(`   âœ… Found structured data`);
  
  // Get updates if any
  const updates = getArticleUpdates(article.id);
  console.log(`   Updates: ${updates.length}`);
  
  // Calculate reading time if not present
  const readingTime = structuredArticle.reading_time_minutes || 
                      calculateReadingTime(structuredArticle.full_report);
  
  // Format dates
  const createdAt = new Date(article.original_pub_date).toISOString();
  const updatedAt = updates.length > 0 && updates[0]
    ? new Date(updates[0].update_date).toISOString()
    : createdAt;
  
  // Create article output
  const output: ArticleOutput = {
    ...structuredArticle,
    reading_time_minutes: readingTime,
    pub_date: article.original_pub_date,
    createdAt: createdAt,
    updatedAt: updatedAt,
    updates: updates.length > 0 ? formatArticleUpdates(updates) : []
  };
  
  // Ensure output directory exists
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }
  
  // Write JSON file
  const outputPath = join(outputDir, `${article.slug}.json`);
  writeFileSync(outputPath, JSON.stringify(output, null, 2), 'utf-8');
  
  console.log(`   âœ… Written to: ${outputPath}`);
  console.log(`   ðŸ“Š Reading time: ${readingTime} min`);
  console.log(`   ðŸ·ï¸  Categories: ${structuredArticle.category.join(', ')}`);
  console.log(`   ðŸ”– Tags: ${structuredArticle.tags.length}`);
  if (structuredArticle.cves && structuredArticle.cves.length > 0) {
    console.log(`   ðŸ›¡ï¸  CVEs: ${structuredArticle.cves.length}`);
  }
}

/**
 * Main execution
 */
async function main() {
  const args = parseArgs();
  const outputDir = args.outputDir || join(process.cwd(), 'public/data/articles');
  
  console.log('='.repeat(60));
  console.log('Step 7B: Generate Article JSON Files');
  console.log('='.repeat(60));
  console.log(`Output directory: ${outputDir}\n`);
  
  let articles: PublishedArticle[] = [];
  
  // Determine which articles to generate
  if (args.slug) {
    const article = getPublishedArticleBySlug(args.slug);
    if (!article) {
      console.error(`âŒ Article not found: ${args.slug}`);
      process.exit(1);
    }
    articles = [article];
  } else if (args.date) {
    articles = getArticlesByDate(args.date);
    if (articles.length === 0) {
      console.error(`âŒ No articles found for date: ${args.date}`);
      process.exit(1);
    }
  } else if (args.all) {
    articles = getAllPublishedArticles();
    if (articles.length === 0) {
      console.error('âŒ No articles found in database');
      process.exit(1);
    }
  } else {
    console.error('Usage:');
    console.error('  npx tsx generate-article-json.ts --slug article-slug');
    console.error('  npx tsx generate-article-json.ts --date 2025-10-09');
    console.error('  npx tsx generate-article-json.ts --all');
    process.exit(1);
  }
  
  console.log(`Found ${articles.length} article(s) to generate\n`);
  
  // Generate JSON for each article
  let successCount = 0;
  let skipCount = 0;
  
  for (const article of articles) {
    try {
      await generateArticleJson(article, outputDir);
      successCount++;
    } catch (error) {
      console.error(`âŒ Error generating ${article.slug}:`, error);
      skipCount++;
    }
  }
  
  console.log('\n' + '='.repeat(60));
  console.log('âœ… Step 7B Complete!');
  console.log('='.repeat(60));
  console.log(`Generated: ${successCount} article JSON file(s)`);
  if (skipCount > 0) {
    console.log(`Skipped: ${skipCount} article(s) (missing structured data)`);
  }
  console.log(`Output: ${outputDir}/`);
}

main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
